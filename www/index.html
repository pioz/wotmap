<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="author" content="pioz" />
    <title>The Wheel of Time Map</title>
    <!-- -------------------- Manifestly head tags begin -------------------- -->
    <meta
      name="viewport"
      content="minimum-scale=1, initial-scale=1, width=device-width, shrink-to-fit=no, viewport-fit=cover, user-scalable=no"
    />
    <meta name="application-name" content="WoT Map" />
    <meta name="theme-color" content="#0e1726" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="WoT Map" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-TileColor" content="#0e1726" />
    <meta name="msapplication-TileImage" content="/icons/ms-icon-150x150.png" />
    <meta name="msapplication-config" content="/browserconfig.xml" />
    <meta name="msapplication-tap-highlight" content="no" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab-icon.svg" color="#ffffff" />
    <link rel="apple-touch-icon" href="/icons/apple-icon-57x57.png" type="image/png" sizes="57x57" />
    <link rel="apple-touch-icon" href="/icons/apple-icon-72x72.png" type="image/png" sizes="72x72" />
    <link rel="apple-touch-icon" href="/icons/apple-icon-76x76.png" type="image/png" sizes="76x76" />
    <link rel="apple-touch-icon" href="/icons/apple-icon-114x114.png" type="image/png" sizes="114x114" />
    <link rel="apple-touch-icon" href="/icons/apple-icon-120x120.png" type="image/png" sizes="120x120" />
    <link rel="apple-touch-icon" href="/icons/apple-icon-144x144.png" type="image/png" sizes="144x144" />
    <link rel="apple-touch-icon" href="/icons/apple-icon-152x152.png" type="image/png" sizes="152x152" />
    <link rel="apple-touch-icon" href="/icons/apple-icon-180x180.png" type="image/png" sizes="180x180" />
    <link rel="icon" href="/icons/android-icon-192x192.png" type="image/png" sizes="192x192" />
    <link rel="icon" href="/icons/favicon-16x16.png" type="image/png" sizes="16x16" />
    <link rel="icon" href="/icons/favicon-32x32.png" type="image/png" sizes="32x32" />
    <link rel="icon" href="/icons/favicon-48x48.png" type="image/png" sizes="48x48" />
    <link rel="manifest" href="/manifest.json" />
    <!-- --------------------- Manifestly head tags end --------------------- -->

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9EXXQ2CB06"></script>
    <script>
      window.dataLayer = window.dataLayer || []
      function gtag() {
        dataLayer.push(arguments)
      }
      gtag('js', new Date())

      gtag('config', 'G-9EXXQ2CB06')
    </script>

    <style>
      :root {
        --white: #e5e7eb;
        --black: #0e1726;
        --ocean-blue: #4a7ecc;
        --dark-black: #020618;
        --gray: rgba(255, 255, 255, 0.12);
      }

      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden; /* prevent page scroll while panning/zooming */
        background: var(--black);
        color: var(--white);
        font-family:
          system-ui,
          -apple-system,
          Roboto,
          Arial;
      }

      .app {
        position: fixed;
        inset: 0;
        display: grid;
        grid-template-rows: auto 1fr;
      }

      .toolbar {
        padding: 10px 12px;
        display: flex;
        align-items: center;
        gap: 12px;
        background: var(--black);
        border-bottom: 1px solid var(--gray);
        user-select: none;
      }

      .btn {
        padding: 6px 10px;
        border: 1px solid var(--gray);
        border-radius: 8px;
        background: transparent;
        color: inherit;
        cursor: pointer;
      }

      .btn:active {
        transform: translateY(1px);
      }

      .input {
        flex: 1;
        width: 0;
        max-width: 200px;
        padding: 6px 10px;
        border: 1px solid var(--gray);
        border-radius: 8px;
        background: var(--black);
        color: var(--white);
      }

      .viewport {
        position: relative;
        overflow: hidden;
        background: var(--dark-black);
        touch-action: none;
        cursor: grab;
      }

      .viewport.dragging {
        cursor: grabbing;
      }

      .content {
        position: absolute;
        top: 0;
        left: 0;
        border: 25px solid var(--gray);
        border-radius: 25px;
        transform-origin: 0 0; /* We'll transform this element to pan & zoom */
        will-change: transform;
        transition: transform 0.4s ease-in-out;
      }

      .content.no-transition {
        transition: none;
      }

      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        display: block;
        pointer-events: none;
        background-color: transparent;
      }

      .hint {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin-left: auto;
        opacity: 0.8;
        font-size: 12px;
      }

      .hint a:link,
      .hint a:visited,
      .hint a:hover,
      .hint a:active {
        color: inherit;
      }

      @media (max-width: 768px) {
        .hint {
          display: none;
        }
      }

      .big-spin {
        width: 48px;
        height: 48px;
        display: inline-block;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      #loader {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        background: linear-gradient(var(--dark-black), var(--black));
        color: var(--white);
        font-size: 18px;
        z-index: 9999;
      }

      #map {
        user-select: none;
        user-drag: none;
        display: block;
        line-height: 0; /* to remove gaps */
      }

      #map img {
        position: absolute;
        display: block;
      }

      #compass {
        position: absolute;
        width: 100px;
        height: 100px;
        bottom: 0;
        left: 0;
        opacity: 0.8;
      }
    </style>
  </head>

  <body>
    <div id="loader">
      <i data-lucide="loader-pinwheel" class="big-spin"></i>
      Loading map…
    </div>

    <div class="app">
      <div class="toolbar">
        <button id="zoomOut" class="btn" title="Zoom Out (-)">−</button>
        <button id="zoomReset" class="btn" title="Reset Zoom (0)">Reset</button>
        <button id="zoomIn" class="btn" title="Zoom In (+)">+</button>
        <button id="toggleBorders" class="btn" title="Toggle Nation Borders (ctrl+B)">Borders</button>
        <input class="input" id="searchInput" type="text" placeholder="Search…" />
        <div class="hint">
          <span> Scroll to zoom · Drag to pan · <a id="btnHelp" href="#">Help</a> </span>
          <a href="https://github.com/pioz/wotmap" target="_blank">
            <i data-lucide="github"></i>
          </a>
        </div>
      </div>

      <div id="viewport" class="viewport">
        <div id="content" class="content">
          <!-- <img id="map" src="map.v1.jpg" alt="Map" fetchpriority="high" /> -->
          <div id="map"></div>
          <svg class="overlay" id="nation-borders-overlay"></svg>
        </div>
        <img id="compass" src="compass.png" alt="Compass" />
      </div>
    </div>

    <script src="https://unpkg.com/lucide@latest" defer onload="lucide.createIcons()"></script>
    <script src="poi.js"></script>
    <script>
      ;(function () {
        // Constants
        ///////////////////////////////////////////////////////////////////////

        const STORAGE_KEY = 'wotmap'
        const EMONDS_FIELD_X = 5194
        const EMONDS_FIELD_Y = 4114
        const MIN_ZOOM = 0.1 // allow zooming out to 10%
        const MAX_ZOOM = 2 // allow zooming in to 200%
        const DEFAULT_ZOOM = 0.8
        const MOVE_STEP = 250
        const ZOOM_STEP = 1.2

        const TILE_WIDTH = 494
        const TILE_HEIGHT = 496
        const TILES_COLS = 30
        const TILES_ROWS = 16
        const MAP_WIDTH = TILE_WIDTH * TILES_COLS
        const MAP_HEIGHT = TILE_HEIGHT * TILES_ROWS
        const TILES_DIR = 'tiles.v1'

        const HELP = `
          SHORTCUTS

          [ArrowUp] → Move up
          [ArrowRight] → Move right
          [ArrowDown] → Move down
          [ArrowLeft] → Move left
          [+] or [shift + ArrowUp] → Zoom in
          [-] or [shift + ArrowDown] → Zoom out
          [0] or [r] → Reset zoom
          [b] → Toggle borders
          [c] → Toggle compass
          [f] → Focus search bar
          [e] → Move to Emond's Field
          [h] → Show this help
        `

        // Elements
        ///////////////////////////////////////////////////////////////////////

        const viewport = document.getElementById('viewport')
        const content = document.getElementById('content')
        const map = document.getElementById('map')
        const compass = document.getElementById('compass')
        const nationBordersSvg = document.getElementById('nation-borders-overlay')
        const loader = document.getElementById('loader')

        // Controls
        const btnIn = document.getElementById('zoomIn')
        const btnOut = document.getElementById('zoomOut')
        const btnReset = document.getElementById('zoomReset')
        const btnBorders = document.getElementById('toggleBorders')
        const searchInput = document.getElementById('searchInput')

        // State
        ///////////////////////////////////////////////////////////////////////

        let zoom = DEFAULT_ZOOM
        let translateX = 0 // pan X in pixels (screen space)
        let translateY = 0 // pan Y in pixels
        let showBorders = false // toggle state
        let showCompass = true // toggle compass

        // Events
        ///////////////////////////////////////////////////////////////////////

        let dragging = false
        let dragStartX = 0
        let dragStartY = 0
        let dragOriginX = 0 // translateX at drag start
        let dragOriginY = 0 // translateY at drag start
        let lastTouchDistance = 0
        let isPinching = false
        let tilesLoadedCount = 0

        // POI (Points of Interesting)
        ///////////////////////////////////////////////////////////////////////

        const poi = window.poi
        const nations = poi.nations
        const locations = poi.locations.concat(poi.rivers).concat(poi.steddings)

        // Render
        ///////////////////////////////////////////////////////////////////////

        function applyTransform() {
          // Apply pan & zoom to the shared container so image and overlays move together
          content.style.transform = `translate(${translateX}px, ${translateY}px) scale(${zoom})`
        }

        // Move/Zoom map functions
        ///////////////////////////////////////////////////////////////////////

        function setCenterOnPoint(imgX, imgY, newZoom = null) {
          if (typeof newZoom === 'number') zoom = clamp(newZoom, MIN_ZOOM, MAX_ZOOM)
          const vw = viewport.clientWidth
          const vh = viewport.clientHeight
          translateX = vw / 2 - imgX * zoom
          translateY = vh / 2 - imgY * zoom
        }

        // Center the image in the viewport (not used)
        function setCenterAtNaturalSize() {
          setCenterOnPoint(MAP_WIDTH / 2, MAP_HEIGHT / 2)
        }

        function move(deltaX, deltaY) {
          translateX += deltaX
          translateY += deltaY
          applyTransform()
          saveState()
        }

        function moveUp(delta = MOVE_STEP) {
          move(0, delta)
        }

        function moveRight(delta = MOVE_STEP) {
          move(-delta, 0)
        }

        function moveDown(delta = MOVE_STEP) {
          move(0, -delta)
        }

        function moveLeft(delta = MOVE_STEP) {
          move(delta, 0)
        }

        function moveToEmondsField() {
          setCenterOnPoint(EMONDS_FIELD_X, EMONDS_FIELD_Y, DEFAULT_ZOOM)
          applyTransform()
          saveState()
        }

        function zoomAt(pointX, pointY, deltaZoom) {
          // Zoom keeping (pointX, pointY) in viewport coords stationary.
          const oldZoom = zoom
          const newZoom = clamp(oldZoom * deltaZoom, MIN_ZOOM, MAX_ZOOM)
          if (newZoom === oldZoom) return

          const contentX = (pointX - translateX) / oldZoom
          const contentY = (pointY - translateY) / oldZoom

          zoom = newZoom
          translateX = pointX - contentX * zoom
          translateY = pointY - contentY * zoom

          applyTransform()
          saveState()
        }

        function zoomAtViewportCenter(deltaZoom) {
          const rect = viewport.getBoundingClientRect()
          zoomAt(rect.width / 2, rect.height / 2, deltaZoom)
        }

        // Reset zoom to default without re-centering the image
        function resetZoom() {
          zoomAtViewportCenter(DEFAULT_ZOOM / zoom)
        }

        function zoomIn(deltaZoom = ZOOM_STEP) {
          zoomAtViewportCenter(deltaZoom)
        }

        function zoomOut(deltaZoom = ZOOM_STEP) {
          zoomAtViewportCenter(1 / deltaZoom)
        }

        // Events
        ///////////////////////////////////////////////////////////////////////

        function handleWheel(e) {
          e.preventDefault()
          const rect = viewport.getBoundingClientRect()
          const mouseX = e.clientX - rect.left
          const mouseY = e.clientY - rect.top
          const zoomFactor = Math.pow(2, -e.deltaY / 1000) // smooth exponential zoom
          zoomAt(mouseX, mouseY, zoomFactor)
        }

        function dragStart(e) {
          e.preventDefault()
          moveMapStart(e.clientX, e.clientY)
        }

        function touchStart(e) {
          if (e.touches.length === 1) {
            // PAN with one finger
            moveMapStart(e.touches[0].clientX, e.touches[0].clientY)
          } else if (e.touches.length === 2) {
            // PINCH ZOOM with two fingers
            isPinching = true
            dragging = false // disable pan
            lastTouchDistance = getTouchDistance(e.touches)
          }
        }

        function moveMapStart(x, y) {
          setDragging(true)
          dragStartX = x
          dragStartY = y
          dragOriginX = translateX
          dragOriginY = translateY
        }

        function duringDrag(e) {
          e.preventDefault()
          duringMoveMap(e.clientX, e.clientY)
        }

        function duringTouchMove(e) {
          e.preventDefault()
          if (dragging && e.touches.length === 1) {
            duringMoveMap(e.touches[0].clientX, e.touches[0].clientY)
          } else if (isPinching && e.touches.length === 2) {
            // update zoom
            const newDist = getTouchDistance(e.touches)
            const deltaZoom = newDist / lastTouchDistance
            lastTouchDistance = newDist
            // center point between fingers
            const rect = viewport.getBoundingClientRect()
            const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left
            const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top
            zoomAt(centerX, centerY, deltaZoom)
          }
        }

        function duringMoveMap(x, y) {
          if (!dragging) return
          translateX = dragOriginX + (x - dragStartX)
          translateY = dragOriginY + (y - dragStartY)
          applyTransform()
        }

        function endDrag() {
          setDragging(false)
          saveState()
        }

        function touchEnd(e) {
          if (e.touches.length === 0) {
            endDrag()
            isPinching = false
            return
          }
          if (isPinching && e.touches.length === 1) {
            isPinching = false
            moveMapStart(e.touches[0].clientX, e.touches[0].clientY)
          }
        }

        function toggleBorders() {
          showBorders = !showBorders
          setBordersVisible(showBorders)
          saveState()
        }

        function toggleCompass() {
          showCompass = !showCompass
          setCompassVisibile(showCompass)
          saveState()
        }

        function showHelp(e) {
          if (e) e.preventDefault()
          alert(HELP)
        }

        function mapLoaded() {
          content.classList.add('no-transition') // to avoid transform transition on
          if (!localStorage.getItem(STORAGE_KEY)) {
            setCenterOnPoint(EMONDS_FIELD_X, EMONDS_FIELD_Y, DEFAULT_ZOOM)
          }
          renderNationBorders(nations)
          setBordersVisible(showBorders)
          setCompassVisibile(showCompass)
          applyTransform()
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              setTimeout(() => {
                content.classList.remove('no-transition')
                loader.style.display = 'none'
              }, 0)
            })
          })
        }

        function tilesLoaded() {
          tilesLoadedCount++
          if (tilesLoadedCount === TILES_COLS * TILES_ROWS) {
            mapLoaded()
          }
        }

        function loadTiles() {
          const frag = document.createDocumentFragment()

          for (let row = 0; row < TILES_ROWS; row++) {
            for (let col = 0; col < TILES_COLS; col++) {
              const img = document.createElement('img')
              img.src = `${TILES_DIR}/tile_${row}_${col}.jpg`
              img.alt = `Map tile ${row},${col}`
              img.style.left = `${col * TILE_WIDTH}px`
              img.style.top = `${row * TILE_HEIGHT}px`
              img.width = TILE_WIDTH
              img.height = TILE_HEIGHT
              img.addEventListener('dragstart', (e) => e.preventDefault())
              if (img.complete) {
                tilesLoaded()
              } else {
                img.addEventListener('load', tilesLoaded)
              }
              frag.appendChild(img)
            }
          }

          map.style.width = `${TILE_WIDTH * TILES_COLS}px`
          map.style.height = `${TILE_HEIGHT * TILES_ROWS}px`
          map.appendChild(frag)
        }

        // LocalStorage state
        ///////////////////////////////////////////////////////////////////////

        function saveState() {
          const state = {
            zoom,
            translateX,
            translateY,
            showBorders,
            showCompass
          }
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state))
        }

        function loadState() {
          try {
            const raw = localStorage.getItem(STORAGE_KEY)
            if (!raw) return
            const state = JSON.parse(raw)
            if (typeof state.zoom === 'number') zoom = state.zoom
            if (typeof state.translateX === 'number') translateX = state.translateX
            if (typeof state.translateY === 'number') translateY = state.translateY
            if (typeof state.showBorders === 'boolean') showBorders = state.showBorders
            if (typeof state.showCompass === 'boolean') showCompass = state.showCompass
          } catch (e) {
            console.warn('Invalid saved state', e)
          }
        }

        // Nation Borders
        ///////////////////////////////////////////////////////////////////////

        function sizeSvgToImage(svg) {
          // Set intrinsic size and viewBox to match the image's native pixels
          svg.setAttribute('width', MAP_WIDTH)
          svg.setAttribute('height', MAP_HEIGHT)
          svg.setAttribute('viewBox', `0 0 ${MAP_WIDTH} ${MAP_HEIGHT}`)
          // For layout: ensure the CSS box matches the image size so it overlaps perfectly
          svg.style.width = MAP_WIDTH + 'px'
          svg.style.height = MAP_HEIGHT + 'px'
        }

        function renderNationBorders(
          nations,
          { strokeWidth = 6, strokeOpacity = 0.85, fill = true, fillOpacity = 0.2, defaultColor = 'rgb(255,0,0)' } = {}
        ) {
          sizeSvgToImage(nationBordersSvg)
          // Clear previous content
          while (nationBordersSvg.firstChild) nationBordersSvg.removeChild(nationBordersSvg.firstChild)

          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
          g.setAttribute('fill-rule', 'evenodd')
          g.setAttribute('stroke-linejoin', 'round')
          g.setAttribute('stroke-linecap', 'round')
          g.setAttribute('stroke-miterlimit', '2')

          for (const nation of nations) {
            if (typeof nation.border !== 'string' || !nation.border.trim()) continue
            const color = nation.color || defaultColor
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
            path.setAttribute('d', nation.border)
            // Stroke
            path.setAttribute('stroke', color)
            path.setAttribute('stroke-width', String(strokeWidth))
            path.setAttribute('stroke-opacity', String(strokeOpacity))
            // Fill
            if (fill) {
              path.setAttribute('fill', color)
              path.setAttribute('fill-opacity', String(fillOpacity))
            } else {
              path.setAttribute('fill', 'none')
            }
            g.appendChild(path)
          }
          nationBordersSvg.appendChild(g)
        }

        function setBordersVisible(visible) {
          nationBordersSvg.style.display = visible ? 'block' : 'none'
        }

        function setCompassVisibile(visible) {
          compass.style.visibility = visible ? 'visible' : 'hidden'
        }

        // Utils
        ///////////////////////////////////////////////////////////////////////

        function clamp(value, min, max) {
          return Math.max(min, Math.min(max, value))
        }

        function setDragging(isDragging) {
          dragging = isDragging
          if (dragging) {
            viewport.classList.add('dragging')
            content.classList.add('no-transition')
            searchInput.value = '' // when dragging remove the input value
          } else {
            viewport.classList.remove('dragging')
            content.classList.remove('no-transition')
          }
        }

        function getTouchDistance(touches) {
          const dx = touches[0].clientX - touches[1].clientX
          const dy = touches[0].clientY - touches[1].clientY
          return Math.sqrt(dx * dx + dy * dy)
        }

        function normalizeString(str) {
          return str.trim().toLowerCase().replace(/\s+/g, '')
        }

        // Searches locations and recenters the view on the first match.
        function search(locations, query, perfectMatch, valueExtractor) {
          if (!Array.isArray(locations) || !query || typeof valueExtractor !== 'function') return false

          for (const location of locations) {
            // Drop falsy values
            const values = valueExtractor(location).filter(Boolean)

            // Check if any value matches according to the selected strategy
            const hasMatch = values.some((v) => {
              const nv = normalizeString(v)
              return perfectMatch ? nv === query : nv.includes(query)
            })

            if (!hasMatch) continue

            const [x, y] = location.coord
            setCenterOnPoint(x, y)
            applyTransform()
            saveState()
            return true
          }

          return false
        }

        // Init
        ///////////////////////////////////////////////////////////////////////

        loadState()

        // Toolbar events
        btnIn.addEventListener('click', () => zoomIn())
        btnOut.addEventListener('click', () => zoomOut())
        btnReset.addEventListener('click', resetZoom)
        btnBorders.addEventListener('click', toggleBorders)
        btnHelp.addEventListener('click', showHelp)

        searchInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            const query = normalizeString(searchInput.value)
            if (!query) return
            if (query.length < 3) return
            searchInput.blur()
            // First search for perfect match
            if (search(locations, query, true, (location) => [location.label])) return
            // Then search aliases for perfect match
            if (search(locations, query, true, (location) => location.aliases || [])) return
            // Then search localizations for perfect match
            if (search(locations, query, true, (location) => Object.values(location.localizations || {}))) return
            // Then search alias localizations for perfect match
            if (search(locations, query, true, (location) => Object.values(location.alias_localizations || {}).flat()))
              return
            // Then search label for inclusion
            if (search(locations, query, false, (location) => [location.label])) return
          }
        })

        searchInput.addEventListener('focus', (e) => {
          searchInput.select()
        })

        function keyPressed(event, key, { ctrlKey = false, altKey = false, metaKey = false, shiftKey = null } = {}) {
          if (event.key !== key) return false

          if (ctrlKey !== null && event.ctrlKey !== ctrlKey) return false
          if (shiftKey !== null && event.shiftKey !== shiftKey) return false
          if (altKey !== null && event.altKey !== altKey) return false
          if (metaKey !== null && event.metaKey !== metaKey) return false

          event.preventDefault()
          return true
        }

        // Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
          if (document.activeElement === searchInput) return

          if (keyPressed(e, '+')) zoomIn()
          if (keyPressed(e, '=')) zoomIn()
          if (keyPressed(e, '-')) zoomOut()
          if (keyPressed(e, 'ArrowUp', { shiftKey: true })) zoomIn()
          if (keyPressed(e, 'ArrowDown', { shiftKey: true })) zoomOut()
          if (keyPressed(e, 'ArrowUp', { shiftKey: false })) moveUp()
          if (keyPressed(e, 'ArrowRight', { shiftKey: false })) moveRight()
          if (keyPressed(e, 'ArrowDown', { shiftKey: false })) moveDown()
          if (keyPressed(e, 'ArrowLeft', { shiftKey: false })) moveLeft()
          if (keyPressed(e, '0')) resetZoom()
          if (keyPressed(e, 'r')) resetZoom()
          if (keyPressed(e, 'b')) toggleBorders()
          if (keyPressed(e, 'c')) toggleCompass()
          if (keyPressed(e, 'f')) searchInput.focus()
          if (keyPressed(e, 'e')) moveToEmondsField()
          if (keyPressed(e, 'h')) showHelp()
          if (keyPressed(e, '?')) showHelp()
          if (keyPressed(e, '/')) showHelp()
        })

        // Mouse events
        viewport.addEventListener('wheel', handleWheel, { passive: false })
        viewport.addEventListener('mousedown', dragStart)
        window.addEventListener('mousemove', duringDrag)
        window.addEventListener('mouseup', endDrag)

        // Mobile events
        viewport.addEventListener('touchstart', touchStart, { passive: false })
        viewport.addEventListener('touchmove', duringTouchMove, {
          passive: false
        })
        viewport.addEventListener('touchend', touchEnd, { passive: false })

        // Recenter on resize to keep the map nicely framed (preserve current zoom and center)
        window.addEventListener('resize', () => zoomAtViewportCenter(1))

        // Start
        if (map.tagName === 'IMG') {
          // Prevent native image drag ghost
          map.addEventListener('dragstart', (e) => e.preventDefault())
          // Initialize after the image loads so we know natural dimensions
          if (map.complete) {
            mapLoaded()
          } else {
            map.addEventListener('load', mapLoaded)
          }

          map.addEventListener('error', () => {
            alert('Fail to load the image map.')
          })
        } else {
          loadTiles()
        }
      })()
    </script>
  </body>
</html>
