<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="minimum-scale=1, initial-scale=1, width=device-width, shrink-to-fit=no, viewport-fit=cover, user-scalable=no"
    />
    <meta name="author" content="pioz" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="manifest" href="manifest.json" />
    <title>The Wheel of Time Map</title>
    <style>
      :root {
        --white: #e5e7eb;
        --black: #0e1726;
        --ocean-blue: #4a7ecc;
        --dark-black: #020618;
        --border-color: rgba(255, 255, 255, 0.12);
      }

      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden; /* prevent page scroll while panning/zooming */
        background: var(--black);
        color: var(--white);
        font-family:
          system-ui,
          -apple-system,
          Roboto,
          Arial;
      }

      .app {
        position: fixed;
        inset: 0;
        display: grid;
        grid-template-rows: auto 1fr;
      }

      .toolbar {
        padding: 10px 12px;
        display: flex;
        align-items: center;
        gap: 12px;
        background: var(--black);
        border-bottom: 1px solid var(--border-color);
        user-select: none;
      }

      .btn {
        padding: 6px 10px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background: transparent;
        color: inherit;
        cursor: pointer;
      }

      .btn:active {
        transform: translateY(1px);
      }

      .input {
        flex: 1;
        width: 0;
        max-width: 200px;
        padding: 6px 10px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background: var(--black);
        color: var(--white);
      }

      .viewport {
        position: relative;
        overflow: hidden;
        background: var(--dark-black);
        touch-action: none;
      }

      .content {
        position: absolute;
        top: 0;
        left: 0;
        border: 25px solid var(--border-color);
        border-radius: 25px;
        transform-origin: 0 0; /* We'll transform this element to pan & zoom */
        will-change: transform;
        cursor: grab;
        transition: transform 0.4s ease-in-out;
      }

      .content.dragging {
        cursor: grabbing;
        transition: none;
      }

      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        display: block;
        pointer-events: none;
        background-color: transparent;
      }

      .hint {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin-left: auto;
        opacity: 0.8;
        font-size: 12px;
      }

      @media (max-width: 768px) {
        .hint {
          display: none;
        }
      }

      #loader {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(var(--dark-black), var(--black));
        color: var(--white);
        font-size: 18px;
        z-index: 9999;
      }

      #map {
        user-select: none;
        -webkit-user-drag: none;
        display: block;
      }
    </style>
  </head>

  <body>
    <div id="loader">Loading map…</div>

    <div class="app">
      <div class="toolbar">
        <button id="zoomOut" class="btn" title="Zoom Out (-)">−</button>
        <button id="zoomReset" class="btn" title="Reset Zoom (0)">Reset</button>
        <button id="zoomIn" class="btn" title="Zoom In (+)">+</button>
        <button id="toggleBorders" class="btn" title="Toggle Nation Borders (ctrl+B)">Borders</button>
        <input class="input" id="searchInput" type="text" placeholder="Search…" />
        <div class="hint">
          Scroll to zoom · Drag to pan
          <a class="hint" href="https://github.com/pioz/wotmap" target="_blank">
            <img src="https://github.githubassets.com/favicons/favicon.png" alt="Contribute" height="28px" />
          </a>
        </div>
      </div>

      <div id="viewport" class="viewport">
        <div id="content" class="content">
          <img id="map" src="map.v1.jpg" alt="Map" fetchpriority="high" decoding="async" />
          <svg class="overlay" id="nation-borders-overlay"></svg>
        </div>
      </div>
    </div>

    <script src="poi.js"></script>
    <script>
      ;(function () {
        // Constants
        ///////////////////////////////////////////////////////////////////////

        const STORAGE_KEY = 'wotmap'
        const EMONDS_FIELD_X = 5194
        const EMONDS_FIELD_Y = 4114
        const MIN_ZOOM = 0.1 // allow zooming out to 10%
        const MAX_ZOOM = 2 // allow zooming in to 200%
        const DEFAULT_ZOOM = 0.8

        // Elements
        ///////////////////////////////////////////////////////////////////////

        const viewport = document.getElementById('viewport')
        const content = document.getElementById('content')
        const img = document.getElementById('map')
        const nationBordersSvg = document.getElementById('nation-borders-overlay')
        const loader = document.getElementById('loader')

        // Controls
        const btnIn = document.getElementById('zoomIn')
        const btnOut = document.getElementById('zoomOut')
        const btnReset = document.getElementById('zoomReset')
        const btnBorders = document.getElementById('toggleBorders')
        const searchInput = document.getElementById('searchInput')

        // State
        ///////////////////////////////////////////////////////////////////////

        let zoom = DEFAULT_ZOOM
        let translateX = 0 // pan X in pixels (screen space)
        let translateY = 0 // pan Y in pixels
        let showBorders = false // toggle state

        // Events
        ///////////////////////////////////////////////////////////////////////

        let dragging = false
        let dragStartX = 0
        let dragStartY = 0
        let dragOriginX = 0 // translateX at drag start
        let dragOriginY = 0 // translateY at drag start
        let lastTouchDistance = 0
        let isPinching = false

        // POI (Points of Interesting)
        ///////////////////////////////////////////////////////////////////////

        const poi = window.poi
        const nations = poi.nations
        const locations = poi.locations.concat(poi.rivers).concat(poi.steddings)

        // LocalStorage state
        ///////////////////////////////////////////////////////////////////////

        function saveState() {
          const state = {
            zoom,
            translateX,
            translateY,
            showBorders
          }
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state))
        }

        function loadState() {
          try {
            const raw = localStorage.getItem(STORAGE_KEY)
            if (!raw) return
            const state = JSON.parse(raw)
            if (typeof state.zoom === 'number') zoom = state.zoom
            if (typeof state.translateX === 'number') translateX = state.translateX
            if (typeof state.translateY === 'number') translateY = state.translateY
            if (typeof state.showBorders === 'boolean') showBorders = state.showBorders
          } catch (e) {
            console.warn('Invalid saved state', e)
          }
        }

        // Render
        ///////////////////////////////////////////////////////////////////////

        function applyTransform() {
          // Apply pan & zoom to the shared container so image and overlays move together
          content.style.transform = `translate(${translateX}px, ${translateY}px) scale(${zoom})`
        }

        // Move/Zoom map functions
        ///////////////////////////////////////////////////////////////////////

        function setCenterOnPoint(imgX, imgY, newZoom = null) {
          if (typeof newZoom === 'number') zoom = clamp(newZoom, MIN_ZOOM, MAX_ZOOM)
          const vw = viewport.clientWidth
          const vh = viewport.clientHeight
          translateX = vw / 2 - imgX * zoom
          translateY = vh / 2 - imgY * zoom
        }

        // Center the image in the viewport
        function setCenterAtNaturalSize() {
          setCenterOnPoint(img.naturalWidth / 2, img.naturalHeight / 2)
        }

        function zoomAt(pointX, pointY, deltaZoom) {
          // Zoom keeping (pointX, pointY) in viewport coords stationary.
          const oldZoom = zoom
          const newZoom = clamp(oldZoom * deltaZoom, MIN_ZOOM, MAX_ZOOM)
          if (newZoom === oldZoom) return

          const contentX = (pointX - translateX) / oldZoom
          const contentY = (pointY - translateY) / oldZoom

          zoom = newZoom
          translateX = pointX - contentX * zoom
          translateY = pointY - contentY * zoom

          applyTransform()
          saveState()
        }

        function zoomAtViewportCenter(deltaZoom) {
          const rect = viewport.getBoundingClientRect()
          zoomAt(rect.width / 2, rect.height / 2, deltaZoom)
        }

        // Reset zoom to default without re-centering the image
        function resetZoom() {
          zoomAtViewportCenter(DEFAULT_ZOOM / zoom)
        }

        // Events
        ///////////////////////////////////////////////////////////////////////

        function handleWheel(e) {
          e.preventDefault()
          const rect = viewport.getBoundingClientRect()
          const mouseX = e.clientX - rect.left
          const mouseY = e.clientY - rect.top
          const zoomFactor = Math.pow(2, -e.deltaY / 1000) // smooth exponential zoom
          zoomAt(mouseX, mouseY, zoomFactor)
        }

        function dragStart(e) {
          e.preventDefault()
          moveMapStart(e.clientX, e.clientY)
        }

        function touchStart(e) {
          if (e.touches.length === 1) {
            // PAN with one finger
            moveMapStart(e.touches[0].clientX, e.touches[0].clientY)
          } else if (e.touches.length === 2) {
            // PINCH ZOOM with two fingers
            isPinching = true
            dragging = false // disable pan
            lastTouchDistance = getTouchDistance(e.touches)
          }
        }

        function moveMapStart(x, y) {
          dragging = true
          content.classList.add('dragging')
          dragStartX = x
          dragStartY = y
          dragOriginX = translateX
          dragOriginY = translateY
          applyTransform()
        }

        function duringDrag(e) {
          e.preventDefault()
          duringMoveMap(e.clientX, e.clientY)
        }

        function duringTouchMove(e) {
          e.preventDefault()
          if (dragging && e.touches.length === 1) {
            duringMoveMap(e.touches[0].clientX, e.touches[0].clientY)
          } else if (isPinching && e.touches.length === 2) {
            // update zoom
            const newDist = getTouchDistance(e.touches)
            const deltaZoom = newDist / lastTouchDistance
            lastTouchDistance = newDist
            // center point between fingers
            const rect = viewport.getBoundingClientRect()
            const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left
            const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top
            zoomAt(centerX, centerY, deltaZoom)
          }
        }

        function duringMoveMap(x, y) {
          if (!dragging) return
          translateX = dragOriginX + (x - dragStartX)
          translateY = dragOriginY + (y - dragStartY)
          applyTransform()
        }

        function endDrag() {
          dragging = false
          content.classList.remove('dragging')
          saveState()
        }

        function touchEnd(e) {
          if (e.touches.length === 0) {
            endDrag()
            isPinching = false
            return
          }
          if (isPinching && e.touches.length === 1) {
            isPinching = false
            moveMapStart(e.touches[0].clientX, e.touches[0].clientY)
          }
        }

        function toggleBorders() {
          showBorders = !showBorders
          setBordersVisible(showBorders)
          saveState()
        }

        function mapLoaded() {
          if (!localStorage.getItem(STORAGE_KEY)) {
            setCenterOnPoint(EMONDS_FIELD_X, EMONDS_FIELD_Y, DEFAULT_ZOOM)
          }
          renderNationBorders(nations)
          setBordersVisible(showBorders)
          applyTransform()
          loader.style.display = 'none'
        }

        // Nation Borders
        ///////////////////////////////////////////////////////////////////////

        function sizeSvgToImage(svg) {
          // Set intrinsic size and viewBox to match the image's native pixels
          const w = img.naturalWidth
          const h = img.naturalHeight
          svg.setAttribute('width', w)
          svg.setAttribute('height', h)
          svg.setAttribute('viewBox', `0 0 ${w} ${h}`)
          // For layout: ensure the CSS box matches the image size so it overlaps perfectly
          svg.style.width = w + 'px'
          svg.style.height = h + 'px'
        }

        function renderNationBorders(
          nations,
          { strokeWidth = 6, strokeOpacity = 0.85, fill = true, fillOpacity = 0.2, defaultColor = 'rgb(255,0,0)' } = {}
        ) {
          sizeSvgToImage(nationBordersSvg)
          // Clear previous content
          while (nationBordersSvg.firstChild) nationBordersSvg.removeChild(nationBordersSvg.firstChild)

          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
          g.setAttribute('fill-rule', 'evenodd')
          g.setAttribute('stroke-linejoin', 'round')
          g.setAttribute('stroke-linecap', 'round')
          g.setAttribute('stroke-miterlimit', '2')

          for (const nation of nations) {
            if (typeof nation.border !== 'string' || !nation.border.trim()) continue
            const color = nation.color || defaultColor
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
            path.setAttribute('d', nation.border)
            // Stroke
            path.setAttribute('stroke', color)
            path.setAttribute('stroke-width', String(strokeWidth))
            path.setAttribute('stroke-opacity', String(strokeOpacity))
            // Fill
            if (fill) {
              path.setAttribute('fill', color)
              path.setAttribute('fill-opacity', String(fillOpacity))
            } else {
              path.setAttribute('fill', 'none')
            }
            g.appendChild(path)
          }
          nationBordersSvg.appendChild(g)
        }

        function setBordersVisible(visible) {
          nationBordersSvg.style.display = visible ? 'block' : 'none'
        }

        // Utils
        ///////////////////////////////////////////////////////////////////////

        function clamp(value, min, max) {
          return Math.max(min, Math.min(max, value))
        }

        function getTouchDistance(touches) {
          const dx = touches[0].clientX - touches[1].clientX
          const dy = touches[0].clientY - touches[1].clientY
          return Math.sqrt(dx * dx + dy * dy)
        }

        function normalizeString(str) {
          return str.trim().toLowerCase().replace(/\s+/g, '')
        }

        // Searches locations and recenters the view on the first match.
        function search(locations, query, perfectMatch, valueExtractor) {
          if (!Array.isArray(locations) || !query || typeof valueExtractor !== 'function') return false

          for (const location of locations) {
            // Drop falsy values
            const values = valueExtractor(location).filter(Boolean)

            // Check if any value matches according to the selected strategy
            const hasMatch = values.some((v) => {
              const nv = normalizeString(v)
              return perfectMatch ? nv === query : nv.includes(query)
            })

            if (!hasMatch) continue

            const [x, y] = location.coord
            setCenterOnPoint(x, y)
            applyTransform()
            saveState()
            return true
          }

          return false
        }

        // Init
        ///////////////////////////////////////////////////////////////////////

        loadState()

        // Toolbar events
        btnIn.addEventListener('click', () => zoomAtViewportCenter(1.2))
        btnOut.addEventListener('click', () => zoomAtViewportCenter(1 / 1.2))
        btnReset.addEventListener('click', resetZoom)
        btnBorders.addEventListener('click', toggleBorders)

        searchInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            const query = normalizeString(searchInput.value)
            if (!query) return
            if (query.length < 3) return
            searchInput.blur()
            // First search for perfect match
            if (search(locations, query, true, (location) => [location.label])) return
            // Then search aliases for perfect match
            if (search(locations, query, true, (location) => location.aliases || [])) return
            // Then search localizations for perfect match
            if (search(locations, query, true, (location) => Object.values(location.localizations || {}))) return
            // Then search alias localizations for perfect match
            if (search(locations, query, true, (location) => Object.values(location.alias_localizations || {}).flat())) return
            // Then search label for inclusion
            if (search(locations, query, false, (location) => [location.label])) return
          }
        })

        searchInput.addEventListener('focus', (e) => {
          searchInput.value = ''
        })

        // Mouse events
        viewport.addEventListener('wheel', handleWheel, { passive: false })
        viewport.addEventListener('mousedown', dragStart)
        window.addEventListener('mousemove', duringDrag)
        window.addEventListener('mouseup', endDrag)

        // Mobile events
        viewport.addEventListener('touchstart', touchStart, { passive: false })
        viewport.addEventListener('touchmove', duringTouchMove, {
          passive: false
        })
        viewport.addEventListener('touchend', touchEnd, { passive: false })

        // Recenter on resize to keep the map nicely framed (preserve current zoom and center)
        window.addEventListener('resize', () => zoomAtViewportCenter(1))

        // Prevent native image drag ghost
        img.addEventListener('dragstart', (e) => e.preventDefault())

        // Initialize after the image loads so we know natural dimensions
        if (img.complete) {
          mapLoaded()
        } else {
          img.addEventListener('load', mapLoaded)
        }

        img.addEventListener('error', () => {
          alert('Fail to load the image map.')
        })

        // Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
          if (e.key === '+' || e.key === 'ArrowUp') btnIn.click()
          if (e.key === '-' || e.key === 'ArrowDown') btnOut.click()
          if (e.key === '0') btnReset.click()
          if ((e.metaKey || e.ctrlKey) && e.key === 'b') btnBorders.click()
          if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'f') {
            e.preventDefault()
            searchInput.focus()
            searchInput.value = ''
          }
        })
      })()
    </script>
  </body>
</html>
